
import logging
from flask import Flask
#from flask import Flask, jsonify
from werkzeug.wsgi import ClosingIterator


# Configure logging
logging.basicConfig(level=logging.INFO)


flask_app = Flask(__name__)

@flask_app.route('/')
def index():
    #return jsonify(message='NATOU est tu la? Manifeste toi !!!')
    return 'NATOU es-tu la? Manifeste toi ALORS !!!'

# You do not need this below when deploying a Flask application with Zappa.
#if __name__ == '__main__':

    # When deploying a Flask application with Zappa, you don't need to include the host, port, and debug parameters b/c the Flask development server (app.run()) is not suitable for use in
    # production environment like AWS Lambda serverless.
    # Zappa handles the deployment and execution of your Flask application on AWS Lambda and API Gateway by taking care of the necessary configurations BY CREATING an AWS Lambda function
    # that is triggered by "API Gateway events".
    #flask_app.run(host='0.0.0.0', port=8000, debug=False)
    # flask_app.run()


# Zappa requires the handler function to be named `lambda_handler`
def lambda_handler(event, context):

    try:
        # Zappa translates the Lambda event into a WSGI-compatible environment
        # wsgi_env = event.get('wsgi_environ', {})
        #wsgi_env = event['wsgi_environ']
        wsgi_env = {
            'wsgi.version': event['wsgi.version'],
            'wsgi.url_scheme': event['wsgi.url_scheme'],
            'wsgi.input': event['wsgi.input'],
            'wsgi.errors': event['wsgi.errors'],
            'wsgi.multiprocess': event['wsgi.multiprocess'],
            'wsgi.multithread': event['wsgi.multithread'],
            'wsgi.run_once': event['wsgi.run_once'],
            'REQUEST_METHOD': event['REQUEST_METHOD'],
            'SCRIPT_NAME': event['SCRIPT_NAME'],
            'PATH_INFO': event['PATH_INFO'],
            'QUERY_STRING': event['QUERY_STRING'],
            'SERVER_NAME': event['SERVER_NAME'],
            'SERVER_PORT': event['SERVER_PORT'],
            'SERVER_PROTOCOL': event['SERVER_PROTOCOL'],
            'HTTP_ACCEPT': event['HTTP_ACCEPT'],
            'HTTP_ACCEPT_ENCODING': event['HTTP_ACCEPT_ENCODING'],
            'HTTP_USER_AGENT': event['HTTP_USER_AGENT']
            # Add more relevant headers as needed
        }


        # Log information
        logging.info("The Lambda function-generated EVENT HAS BEEN SUCCESSFULLY PARSED : %s", event)

        # Call the Flask app with the translated environment
        flask_response = flask_app.wsgi_app(wsgi_env, lambda response, start_response: "None")
        #flask_response = flask_app.wsgi_app(wsgi_env, lambda response, start_response: None)
        #flask_response = ClosingIterator(flask_app.wsgi_app(wsgi_env, lambda response, start_response: None))

        # Log success
        logging.info("The Flask OBJECT HAS SUCCESSFULLY PROCESSED the event generated by the Lambda function.")
        logging.info(f"RESPONSE of Flask App OBJECT : {flask_response}")

        # In Flask the response object is typically an iterable and should be iterated over instead of trying to access it like a list
        if flask_response is not None:

            if hasattr(flask_response, '__iter__'):
                # Assuming flask_response is already of the type ClosingIterator object
                logging.info(f"The RESPONSE of the Flask App object is of the TYPE : {type(flask_response)}")
                #  The b prefix before a string indicates to treat it as a bytes literal rather than a string literal. Bytes literals are sequences of bytes, each representing
                #  a character in ASCII (or more generally in the Unicode character set).
                logging.info(f"The CONTENT of the Flask App Response is: {b''.join(flask_response)}")
                
                #response_in_bytes_format = b''.join(flask_response)
                #body = response_in_bytes_format.decode('utf-8')
                body = "PAPA"

            else:
                logging.info(f"Flask response is Not Iterable")
                body = ['Flask response is Not Iterable']
                #body = [b''.join(flask_response)]

        else:
            logging.info(f"Flask response is None")
            body = ['Flask response is None']
            #body = [b'Error: Flask response is None']

        # Now you can use the 'body' variable as needed
        return body
        # return {
        #     'statusCode': 200,
        #     'body': body
        # }

    except Exception as e:

        # Log the exception
        logging.error("An error HAS occurred: %s", str(e))
        logging.info("Lambda Event: %s", event)

        # Handle exceptions and return an error response if needed
        return {
            'statusCode': 850,
            'body': f'Error: {str(e)}'
        }
